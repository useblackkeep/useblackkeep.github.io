<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-eval' https://www.gstatic.com https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://*.firebaseio.com https://*.googleapis.com wss://*.firebaseio.com; img-src 'self' data:;">
    <title>BlackKeep</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b0b0f;
            --bg-elevated: #101016;
            --bg-surface: #16161d;
            --fg: #e8e8ec;
            --fg-muted: #6b6b78;
            --accent: #00d4ff;
            --accent-dim: #00d4ff33;
            --error: #ff3b5c;
            --success: #00ff88;
            --warning: #ffb800;
            --border: #2a2a35;
            --glow: 0 0 20px var(--accent-dim);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg);
            color: var(--fg);
            font-size: 13px;
            line-height: 1.6;
            letter-spacing: -0.01em;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
        }

        /* Header */
        .header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-elevated);
        }

        .logo {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.15em;
            color: var(--fg);
        }

        .logo span {
            color: var(--accent);
        }

        .room-info {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .room-code {
            font-size: 12px;
            color: var(--fg-muted);
            background: var(--bg-surface);
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        .room-code strong {
            color: var(--accent);
            font-weight: 500;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--fg-muted);
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--fg-muted);
            transition: background 0.3s ease;
        }

        .status-dot.connected {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .status-dot.connecting {
            background: var(--warning);
            animation: pulse 1s infinite;
        }

        .status-dot.error {
            background: var(--error);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Sidebar - Peers */
        .sidebar {
            width: 200px;
            border-right: 1px solid var(--border);
            background: var(--bg-elevated);
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 12px 16px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--fg-muted);
            border-bottom: 1px solid var(--border);
        }

        .peer-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .peer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 4px;
            transition: background 0.2s ease;
        }

        .peer-item:hover {
            background: var(--bg-surface);
        }

        .peer-avatar {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            background: var(--bg-surface);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--accent);
            border: 1px solid var(--border);
        }

        .peer-info {
            flex: 1;
            min-width: 0;
        }

        .peer-name {
            font-size: 12px;
            color: var(--fg);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .peer-status {
            font-size: 10px;
            color: var(--fg-muted);
        }

        /* Chat Area */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg);
        }

        /* Connection Status Overlay */
        .connection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(11, 11, 15, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .connection-overlay.hidden {
            display: none;
        }

        .connection-status {
            font-size: 12px;
            color: var(--fg-muted);
            margin-bottom: 24px;
        }

        .status-lines {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 400px;
        }

        .status-line {
            font-size: 13px;
            color: var(--fg-muted);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.4s ease;
        }

        .status-line.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .status-line.success {
            color: var(--success);
        }

        .status-line.error {
            color: var(--error);
        }

        .status-line .prefix {
            color: var(--accent);
            margin-right: 8px;
        }

        /* Messages */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .message {
            margin-bottom: 16px;
            animation: messageIn 0.3s ease;
        }

        @keyframes messageIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 4px;
        }

        .message-sender {
            font-size: 12px;
            font-weight: 500;
            color: var(--accent);
        }

        .message-sender.self {
            color: var(--success);
        }

        .message-time {
            font-size: 10px;
            color: var(--fg-muted);
        }

        .message-content {
            background: var(--bg-elevated);
            padding: 10px 14px;
            border-radius: 6px;
            border: 1px solid var(--border);
            font-size: 13px;
            color: var(--fg);
            word-break: break-word;
            max-width: 70%;
        }

        .message-content.file-transfer {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .message-content.file-transfer:hover {
            border-color: var(--accent);
            background: var(--bg-surface);
        }

        .file-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-surface);
            border-radius: 4px;
            color: var(--accent);
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-size: 12px;
            color: var(--fg);
            margin-bottom: 2px;
        }

        .file-size {
            font-size: 10px;
            color: var(--fg-muted);
        }

        .file-progress {
            width: 60px;
            height: 4px;
            background: var(--bg-surface);
            border-radius: 2px;
            overflow: hidden;
        }

        .file-progress-bar {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s ease;
        }

        /* System Messages */
        .system-message {
            text-align: center;
            font-size: 11px;
            color: var(--fg-muted);
            margin: 16px 0;
            padding: 8px;
            background: var(--bg-elevated);
            border-radius: 4px;
            border: 1px dashed var(--border);
        }

        .system-message.error {
            color: var(--error);
            border-color: var(--error);
        }

        .system-message.success {
            color: var(--success);
            border-color: var(--success);
        }

        /* Input Area */
        .input-area {
            padding: 16px;
            border-top: 1px solid var(--border);
            background: var(--bg-elevated);
        }

        .input-row {
            display: flex;
            gap: 8px;
        }

        .message-input {
            flex: 1;
            background: var(--bg-surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px 16px;
            color: var(--fg);
            font-family: inherit;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s ease;
        }

        .message-input:focus {
            border-color: var(--accent);
        }

        .message-input::placeholder {
            color: var(--fg-muted);
        }

        .btn {
            padding: 12px 20px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-surface);
            color: var(--fg);
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .btn:hover {
            border-color: var(--accent);
            background: var(--bg-elevated);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg);
            border-color: var(--accent);
            font-weight: 500;
        }

        .btn-primary:hover {
            background: #00b8e0;
            border-color: #00b8e0;
        }

        .btn-danger {
            border-color: var(--error);
            color: var(--error);
        }

        .btn-danger:hover {
            background: var(--error);
            color: var(--bg);
        }

        .btn-icon {
            padding: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Join/Create Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(11, 11, 15, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            backdrop-filter: blur(8px);
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 32px;
            width: 100%;
            max-width: 420px;
            animation: modalIn 0.3s ease;
        }

        @keyframes modalIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-title {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--fg);
            letter-spacing: 0.05em;
        }

        .modal-subtitle {
            font-size: 11px;
            color: var(--fg-muted);
            margin-bottom: 24px;
        }

        .input-group {
            margin-bottom: 16px;
        }

        .input-label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--fg-muted);
            margin-bottom: 8px;
        }

        .input-field {
            width: 100%;
            background: var(--bg-surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px 16px;
            color: var(--fg);
            font-family: inherit;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            text-align: center;
        }

        .input-field:focus {
            border-color: var(--accent);
        }

        .input-field::placeholder {
            color: var(--fg-muted);
            letter-spacing: 0.1em;
            text-transform: none;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .modal-actions .btn {
            flex: 1;
        }

        .modal-divider {
            display: flex;
            align-items: center;
            gap: 16px;
            margin: 24px 0;
            color: var(--fg-muted);
            font-size: 10px;
        }

        .modal-divider::before,
        .modal-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
        }

        /* Purge Animation */
        .purge-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            animation: purgeIn 0.5s ease;
        }

        .purge-overlay.hidden {
            display: none;
        }

        @keyframes purgeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .purge-text {
            font-size: 14px;
            color: var(--error);
            margin-bottom: 12px;
            letter-spacing: 0.1em;
        }

        .purge-subtext {
            font-size: 12px;
            color: var(--success);
        }

        /* File input hidden */
        .file-input-hidden {
            display: none;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--fg-muted);
        }

        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--fg-muted);
            text-align: center;
            padding: 32px;
        }

        .empty-state-icon {
            width: 48px;
            height: 48px;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 12px;
            max-width: 300px;
        }

        /* Ratchet indicator */
        .ratchet-indicator {
            position: absolute;
            bottom: 80px;
            right: 16px;
            font-size: 10px;
            color: var(--fg-muted);
            background: var(--bg-elevated);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .ratchet-indicator.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="app-container" id="app">
        <!-- Join/Create Modal -->
        <div class="modal-overlay" id="joinModal">
            <div class="modal">
                <div class="modal-title">BLACKKEEP</div>
                <div class="modal-subtitle">End-to-end encrypted P2P communication</div>
                
                <div class="input-group">
                    <label class="input-label" for="roomCodeInput">Room Code</label>
                    <input type="text" class="input-field" id="roomCodeInput" maxlength="8" placeholder="Enter 8-character code" autocomplete="off" spellcheck="false">
                </div>
                
                <div class="modal-actions">
                    <button class="btn btn-primary" id="joinBtn">Join Room</button>
                </div>
                
                <div class="modal-divider">or</div>
                
                <button class="btn" id="createBtn" style="width: 100%;">Create New Room</button>
            </div>
        </div>

        <!-- Connection Overlay -->
        <div class="connection-overlay hidden" id="connectionOverlay">
            <div class="status-lines" id="statusLines"></div>
        </div>

        <!-- Purge Overlay -->
        <div class="purge-overlay hidden" id="purgeOverlay">
            <div class="purge-text">[!] ROOM PURGED</div>
            <div class="purge-subtext">[+] Memory zeroized.</div>
        </div>

        <!-- Main App -->
        <header class="header">
            <div class="logo">BLACK<span>KEEP</span></div>
            <div class="room-info">
                <div class="room-code" id="roomCodeDisplay">Room: <strong>--------</strong></div>
                <div class="status-indicator">
                    <div class="status-dot" id="connectionDot"></div>
                    <span id="connectionText">Disconnected</span>
                </div>
                <button class="btn btn-danger btn-icon" id="leaveBtn" title="Leave Room" aria-label="Leave Room">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                        <polyline points="16,17 21,12 16,7"></polyline>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                </button>
            </div>
        </header>

        <main class="main-content">
            <aside class="sidebar">
                <div class="sidebar-header">Peers Online</div>
                <div class="peer-list" id="peerList">
                    <div class="empty-state" id="emptyPeers">
                        <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <div class="empty-state-text">No peers connected</div>
                    </div>
                </div>
            </aside>

            <section class="chat-area">
                <div class="messages-container" id="messagesContainer"></div>
                
                <div class="ratchet-indicator" id="ratchetIndicator">
                    Key rotation in <span id="ratchetCountdown">60</span>s
                </div>

                <div class="input-area">
                    <div class="input-row">
                        <input type="file" class="file-input-hidden" id="fileInput" aria-label="Select file">
                        <button class="btn btn-icon" id="attachBtn" title="Attach file" aria-label="Attach file">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                            </svg>
                        </button>
                        <input type="text" class="message-input" id="messageInput" placeholder="Type a message..." autocomplete="off" aria-label="Message input">
                        <button class="btn btn-primary" id="sendBtn">Send</button>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js" integrity="sha384-t2Q4P0xBIQhPzIoU9GJjEJnS4gAOI8qNjLFr+WkE6UV5LKpnzQVouyFwSYCNZN3s" crossorigin="anonymous"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js" integrity="sha384-5LmJG9VJGVwqPVXZz9CwVXll0AQRJ6KlF0WZ7hA8VzBvRN0y7xLLJzgdBfXvDwfF" crossorigin="anonymous"></script>
    <script src="crypto.js"></script>
    <script src="FirebaseAPI.js"></script>
    <script>
        'use strict';

        const BlackKeep = (function() {
            const PEER_ID_LENGTH = 8;
            const MAX_FILE_SIZE = 10 * 1024 * 1024;
            const CHUNK_SIZE = 64 * 1024;
            const RATCHET_INTERVAL = 60000;
            const DUMMY_TRAFFIC_INTERVAL = 5000;
            const ROOM_EXPIRY_MS = 120000;
            const MAX_FAILED_ATTEMPTS = 5;

            let state = {
                roomId: null,
                peerId: null,
                displayName: null,
                cryptoContext: null,
                connections: new Map(),
                dataChannels: new Map(),
                peerNames: new Map(),
                ratchetTimer: null,
                dummyTrafficTimer: null,
                ratchetCountdown: 60,
                countdownTimer: null,
                unsubscribeSignals: null,
                unsubscribeRoom: null,
                isJoined: false,
                pendingCandidates: new Map()
            };

            let dom = {};

            function initDOM() {
                dom = {
                    joinModal: document.getElementById('joinModal'),
                    connectionOverlay: document.getElementById('connectionOverlay'),
                    purgeOverlay: document.getElementById('purgeOverlay'),
                    statusLines: document.getElementById('statusLines'),
                    roomCodeInput: document.getElementById('roomCodeInput'),
                    joinBtn: document.getElementById('joinBtn'),
                    createBtn: document.getElementById('createBtn'),
                    leaveBtn: document.getElementById('leaveBtn'),
                    roomCodeDisplay: document.getElementById('roomCodeDisplay'),
                    connectionDot: document.getElementById('connectionDot'),
                    connectionText: document.getElementById('connectionText'),
                    peerList: document.getElementById('peerList'),
                    emptyPeers: document.getElementById('emptyPeers'),
                    messagesContainer: document.getElementById('messagesContainer'),
                    messageInput: document.getElementById('messageInput'),
                    sendBtn: document.getElementById('sendBtn'),
                    fileInput: document.getElementById('fileInput'),
                    attachBtn: document.getElementById('attachBtn'),
                    ratchetIndicator: document.getElementById('ratchetIndicator'),
                    ratchetCountdown: document.getElementById('ratchetCountdown')
                };
            }

            function generatePeerId() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let result = '';
                const array = new Uint8Array(PEER_ID_LENGTH);
                crypto.getRandomValues(array);
                for (let i = 0; i < PEER_ID_LENGTH; i++) {
                    result += chars[array[i] % chars.length];
                }
                return result;
            }

            function generateDisplayName() {
                const adjectives = ['Silent', 'Dark', 'Swift', 'Cryptic', 'Shadow', 'Ghost', 'Cipher', 'Void'];
                const nouns = ['Node', 'Agent', 'Runner', 'Ghost', 'Signal', 'Echo', 'Phantom', 'Specter'];
                const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
                const noun = nouns[Math.floor(Math.random() * nouns.length)];
                const num = Math.floor(Math.random() * 100);
                return `${adj}${noun}${num}`;
            }

            async function showConnectionStatus(steps) {
                dom.connectionOverlay.classList.remove('hidden');
                dom.statusLines.textContent = '';
                
                for (let i = 0; i < steps.length; i++) {
                    await new Promise(r => setTimeout(r, 300 + Math.random() * 400));
                    const line = document.createElement('div');
                    line.className = 'status-line';
                    const step = steps[i];
                    const prefix = step.success ? '[+]' : (step.error ? '[!]' : '[+]');
                    line.textContent = `${prefix} ${step.text}`;
                    if (step.success) line.classList.add('success');
                    if (step.error) line.classList.add('error');
                    dom.statusLines.appendChild(line);
                    await new Promise(r => setTimeout(r, 50));
                    line.classList.add('visible');
                }
            }

            function hideConnectionOverlay() {
                setTimeout(() => {
                    dom.connectionOverlay.classList.add('hidden');
                }, 800);
            }

            function setConnectionStatus(status, text) {
                dom.connectionDot.className = 'status-dot ' + status;
                dom.connectionText.textContent = text;
            }

            function addSystemMessage(text, type = 'info') {
                const msg = document.createElement('div');
                msg.className = `system-message ${type}`;
                msg.textContent = text;
                dom.messagesContainer.appendChild(msg);
                scrollToBottom();
            }

            function addChatMessage(sender, content, isSelf, fileData = null) {
                const msg = document.createElement('div');
                msg.className = 'message';
                
                const header = document.createElement('div');
                header.className = 'message-header';
                
                const senderEl = document.createElement('span');
                senderEl.className = `message-sender ${isSelf ? 'self' : ''}`;
                senderEl.textContent = sender;
                
                const timeEl = document.createElement('span');
                timeEl.className = 'message-time';
                timeEl.textContent = new Date().toLocaleTimeString();
                
                header.appendChild(senderEl);
                header.appendChild(timeEl);
                msg.appendChild(header);
                
                const contentEl = document.createElement('div');
                contentEl.className = 'message-content';
                
                if (fileData) {
                    contentEl.classList.add('file-transfer');
                    contentEl.innerHTML = `
                        <div class="file-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                            </svg>
                        </div>
                        <div class="file-info">
                            <div class="file-name">${escapeHtml(fileData.name)}</div>
                            <div class="file-size">${formatFileSize(fileData.size)}</div>
                        </div>
                    `;
                    contentEl.addEventListener('click', () => downloadFile(fileData));
                } else {
                    contentEl.textContent = content;
                }
                
                msg.appendChild(contentEl);
                dom.messagesContainer.appendChild(msg);
                scrollToBottom();
            }

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            function formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            }

            function scrollToBottom() {
                dom.messagesContainer.scrollTop = dom.messagesContainer.scrollHeight;
            }

            function updatePeerList() {
                const peers = Array.from(state.peerNames.entries());
                
                if (peers.length === 0) {
                    dom.emptyPeers.style.display = 'flex';
                    return;
                }
                
                dom.emptyPeers.style.display = 'none';
                
                const existingIds = new Set();
                dom.peerList.querySelectorAll('.peer-item').forEach(el => {
                    existingIds.add(el.dataset.peerId);
                });
                
                peers.forEach(([peerId, name]) => {
                    if (!existingIds.has(peerId)) {
                        const item = document.createElement('div');
                        item.className = 'peer-item';
                        item.dataset.peerId = peerId;
                        item.innerHTML = `
                            <div class="peer-avatar">${name.charAt(0).toUpperCase()}</div>
                            <div class="peer-info">
                                <div class="peer-name">${escapeHtml(name)}</div>
                                <div class="peer-status">Connected</div>
                            </div>
                        `;
                        dom.peerList.appendChild(item);
                    }
                });
                
                dom.peerList.querySelectorAll('.peer-item').forEach(el => {
                    if (!peers.some(([id]) => id === el.dataset.peerId)) {
                        el.remove();
                    }
                });
            }

            async function createRoom() {
                try {
                    state.peerId = generatePeerId();
                    state.displayName = generateDisplayName();
                    state.cryptoContext = await CryptoModule.createContext();
                    
                    await showConnectionStatus([
                        { text: 'Seeding entropy pool...' },
                        { text: 'Generating cryptographic identity...' },
                        { text: 'Creating secure room...' },
                        { text: 'Room initialized', success: true }
                    ]);
                    
                    const roomId = await FirebaseAPI.createRoom(state.peerId, state.cryptoContext.publicKey);
                    state.roomId = roomId;
                    
                    dom.roomCodeDisplay.innerHTML = `Room: <strong>${roomId}</strong>`;
                    hideConnectionOverlay();
                    setConnectionStatus('connecting', 'Waiting for peers...');
                    
                    await listenForSignals();
                    startRatchet();
                    startDummyTraffic();
                    
                    addSystemMessage(`Room created. Code: ${roomId}`, 'success');
                    addSystemMessage('Share this code with trusted peers only.');
                    
                    state.isJoined = true;
                    
                } catch (err) {
                    await showConnectionStatus([
                        { text: 'Failed to create room', error: true },
                        { text: err.message, error: true }
                    ]);
                    setTimeout(hideConnectionOverlay, 2000);
                }
            }

            async function joinRoom() {
                const code = dom.roomCodeInput.value.trim().toUpperCase();
                if (code.length !== 8 || !/^[A-Z0-9]{8}$/.test(code)) {
                    addSystemMessage('Invalid room code format', 'error');
                    return;
                }
                
                try {
                    state.peerId = generatePeerId();
                    state.displayName = generateDisplayName();
                    state.cryptoContext = await CryptoModule.createContext();
                    state.roomId = code;
                    
                    await showConnectionStatus([
                        { text: 'Querying distributed relay...' },
                        { text: 'Verifying room integrity...' },
                        { text: 'Deriving shared secret...' },
                        { text: 'Activating forward secrecy...' },
                        { text: 'Secure channel established.', success: true }
                    ]);
                    
                    const room = await FirebaseAPI.joinRoom(state.roomId, state.peerId, state.cryptoContext.publicKey);
                    
                    if (!room) {
                        throw new Error('Room not found or expired');
                    }
                    
                    if (room.locked) {
                        throw new Error('Room is locked due to failed attempts');
                    }
                    
                    dom.roomCodeDisplay.innerHTML = `Room: <strong>${state.roomId}</strong>`;
                    hideConnectionOverlay();
                    setConnectionStatus('connecting', 'Establishing connections...');
                    
                    await listenForSignals();
                    await connectToPeers(room.peers);
                    startRatchet();
                    startDummyTraffic();
                    
                    addSystemMessage(`Joined room: ${state.roomId}`, 'success');
                    
                    state.isJoined = true;
                    
                } catch (err) {
                    await FirebaseAPI.incrementFailedAttempts(state.roomId);
                    await showConnectionStatus([
                        { text: 'Failed to join room', error: true },
                        { text: err.message, error: true }
                    ]);
                    setTimeout(hideConnectionOverlay, 2000);
                }
            }

            async function listenForSignals() {
                state.unsubscribeSignals = FirebaseAPI.listenForSignals(
                    state.roomId,
                    state.peerId,
                    async (signal) => {
                        await handleSignal(signal);
                    }
                );
            }

            async function handleSignal(signal) {
                try {
                    const decrypted = await CryptoModule.decryptSignal(
                        signal.encryptedBlob,
                        state.cryptoContext
                    );
                    
                    const data = JSON.parse(decrypted);
                    
                    if (data.type === 'offer') {
                        await handleOffer(data, signal.from);
                    } else if (data.type === 'answer') {
                        await handleAnswer(data, signal.from);
                    } else if (data.type === 'candidate') {
                        await handleCandidate(data, signal.from);
                    } else if (data.type === 'peer-info') {
                        state.peerNames.set(signal.from, data.name);
                        updatePeerList();
                    }
                } catch (err) {
                    console.error('Signal handling error:', err);
                }
            }

            async function connectToPeers(peers) {
                for (const peer of peers) {
                    if (peer.id !== state.peerId) {
                        await createConnection(peer.id, peer.publicKey);
                    }
                }
            }

            async function createConnection(peerId, peerPublicKey) {
                if (state.connections.has(peerId)) return;
                
                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });
                
                state.connections.set(peerId, pc);
                
                const sharedSecret = await CryptoModule.deriveSharedSecret(
                    state.cryptoContext.keyPair.privateKey,
                    peerPublicKey
                );
                
                const sessionKeys = await CryptoModule.deriveSessionKeys(sharedSecret);
                
                pc.onicecandidate = async (event) => {
                    if (event.candidate) {
                        await sendSignal(peerId, {
                            type: 'candidate',
                            candidate: event.candidate.toJSON()
                        });
                    }
                };
                
                pc.onconnectionstatechange = () => {
                    if (pc.connectionState === 'connected') {
                        setConnectionStatus('connected', 'Secure connection active');
                        updatePeerList();
                    } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                        handlePeerDisconnect(peerId);
                    }
                };
                
                const dc = pc.createDataChannel('blackkeep', {
                    ordered: true
                });
                
                setupDataChannel(dc, peerId, sessionKeys);
                
                state.dataChannels.set(peerId, { channel: dc, keys: sessionKeys });
                
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                await sendSignal(peerId, {
                    type: 'offer',
                    sdp: offer.sdp
                });
                
                await sendSignal(peerId, {
                    type: 'peer-info',
                    name: state.displayName
                });
            }

            async function handleOffer(data, fromPeerId) {
                let pc = state.connections.get(fromPeerId);
                
                if (!pc) {
                    pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });
                    
                    state.connections.set(fromPeerId, pc);
                    
                    pc.onconnectionstatechange = () => {
                        if (pc.connectionState === 'connected') {
                            setConnectionStatus('connected', 'Secure connection active');
                        } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                            handlePeerDisconnect(fromPeerId);
                        }
                    };
                }
                
                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: data.sdp
                }));
                
                const pending = state.pendingCandidates.get(fromPeerId) || [];
                for (const candidate of pending) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                }
                state.pendingCandidates.delete(fromPeerId);
                
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                
                await sendSignal(fromPeerId, {
                    type: 'answer',
                    sdp: answer.sdp
                });
                
                pc.ondatachannel = (event) => {
                    const dc = event.channel;
                    
                    FirebaseAPI.getPeerPublicKey(state.roomId, fromPeerId).then(async (peerPublicKey) => {
                        const sharedSecret = await CryptoModule.deriveSharedSecret(
                            state.cryptoContext.keyPair.privateKey,
                            peerPublicKey
                        );
                        const sessionKeys = await CryptoModule.deriveSessionKeys(sharedSecret);
                        
                        setupDataChannel(dc, fromPeerId, sessionKeys);
                        state.dataChannels.set(fromPeerId, { channel: dc, keys: sessionKeys });
                    });
                };
            }

            async function handleAnswer(data, fromPeerId) {
                const pc = state.connections.get(fromPeerId);
                if (pc) {
                    await pc.setRemoteDescription(new RTCSessionDescription({
                        type: 'answer',
                        sdp: data.sdp
                    }));
                }
            }

            async function handleCandidate(data, fromPeerId) {
                const pc = state.connections.get(fromPeerId);
                if (pc && pc.remoteDescription) {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                } else {
                    const pending = state.pendingCandidates.get(fromPeerId) || [];
                    pending.push(data.candidate);
                    state.pendingCandidates.set(fromPeerId, pending);
                }
            }

            function setupDataChannel(dc, peerId, sessionKeys) {
                dc.onopen = () => {
                    setConnectionStatus('connected', 'Secure channel established');
                    addSystemMessage(`${state.peerNames.get(peerId) || peerId} connected`, 'success');
                };
                
                dc.onclose = () => {
                    handlePeerDisconnect(peerId);
                };
                
                dc.onmessage = async (event) => {
                    await handleDataChannelMessage(event.data, peerId, sessionKeys);
                };
            }

            async function handleDataChannelMessage(encryptedData, peerId, sessionKeys) {
                try {
                    const decrypted = await CryptoModule.decryptMessage(
                        encryptedData,
                        sessionKeys.decryptionKey
                    );
                    
                    const message = JSON.parse(decrypted);
                    
                    if (message.type === 'chat') {
                        addChatMessage(
                            state.peerNames.get(peerId) || peerId,
                            message.content,
                            false
                        );
                    } else if (message.type === 'file') {
                        addChatMessage(
                            state.peerNames.get(peerId) || peerId,
                            null,
                            false,
                            message.file
                        );
                    } else if (message.type === 'file-chunk') {
                        handleFileChunk(message, peerId);
                    } else if (message.type === 'dummy') {
                        // Dummy traffic, ignore
                    }
                    
                } catch (err) {
                    console.error('Message decryption error:', err);
                }
            }

            async function sendSignal(toPeerId, data) {
                const delay = 100 + Math.random() * 600;
                await new Promise(r => setTimeout(r, delay));
                
                const encrypted = await CryptoModule.encryptSignal(
                    JSON.stringify(data),
                    state.cryptoContext
                );
                
                await FirebaseAPI.sendSignal(
                    state.roomId,
                    state.peerId,
                    toPeerId,
                    encrypted
                );
            }

            async function sendMessage() {
                const content = dom.messageInput.value.trim();
                if (!content) return;
                
                const message = {
                    type: 'chat',
                    content: content,
                    timestamp: Date.now()
                };
                
                addChatMessage(state.displayName, content, true);
                dom.messageInput.value = '';
                
                await broadcastMessage(message);
            }

            async function broadcastMessage(message) {
                const promises = [];
                
                state.dataChannels.forEach(async ({ channel, keys }, peerId) => {
                    if (channel.readyState === 'open') {
                        const encrypted = await CryptoModule.encryptMessage(
                            JSON.stringify(message),
                            keys.encryptionKey
                        );
                        channel.send(encrypted);
                    }
                });
            }

            async function sendFile(file) {
                if (file.size > MAX_FILE_SIZE) {
                    addSystemMessage('File exceeds 10MB limit', 'error');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = async () => {
                    const arrayBuffer = reader.result;
                    const hash = await CryptoModule.hashBuffer(arrayBuffer);
                    
                    const fileMeta = {
                        type: 'file',
                        file: {
                            name: file.name,
                            size: file.size,
                            hash: hash,
                            data: Array.from(new Uint8Array(arrayBuffer))
                        },
                        timestamp: Date.now()
                    };
                    
                    addChatMessage(state.displayName, null, true, fileMeta.file);
                    await broadcastMessage(fileMeta);
                };
                reader.readAsArrayBuffer(file);
            }

            function downloadFile(fileData) {
                const blob = new Blob([new Uint8Array(fileData.data)], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileData.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function handlePeerDisconnect(peerId) {
                const name = state.peerNames.get(peerId) || peerId;
                addSystemMessage(`${name} disconnected`, 'info');
                
                state.connections.delete(peerId);
                state.dataChannels.delete(peerId);
                state.peerNames.delete(peerId);
                
                updatePeerList();
                
                if (state.connections.size === 0) {
                    setConnectionStatus('connecting', 'Waiting for peers...');
                }
            }

            function startRatchet() {
                if (state.ratchetTimer) clearInterval(state.ratchetTimer);
                if (state.countdownTimer) clearInterval(state.countdownTimer);
                
                state.ratchetCountdown = 60;
                dom.ratchetIndicator.classList.add('visible');
                
                state.countdownTimer = setInterval(() => {
                    state.ratchetCountdown--;
                    dom.ratchetCountdown.textContent = state.ratchetCountdown;
                    
                    if (state.ratchetCountdown <= 0) {
                        state.ratchetCountdown = 60;
                    }
                }, 1000);
                
                state.ratchetTimer = setInterval(async () => {
                    await performRatchet();
                }, RATCHET_INTERVAL);
            }

            async function performRatchet() {
                addSystemMessage('Rotating encryption keys...', 'info');
                
                state.dataChannels.forEach(async ({ keys }, peerId) => {
                    const newKeys = await CryptoModule.ratchetKeys(keys);
                    const entry = state.dataChannels.get(peerId);
                    if (entry) {
                        entry.keys = newKeys;
                    }
                });
                
                addSystemMessage('Keys rotated', 'success');
            }

            function startDummyTraffic() {
                if (state.dummyTrafficTimer) clearInterval(state.dummyTrafficTimer);
                
                state.dummyTrafficTimer = setInterval(async () => {
                    if (state.dataChannels.size > 0) {
                        const dummyMessage = {
                            type: 'dummy',
                            padding: CryptoModule.generateRandomPadding()
                        };
                        
                        await broadcastMessage(dummyMessage);
                    }
                }, DUMMY_TRAFFIC_INTERVAL);
            }

            async function leaveRoom() {
                await purgeRoom();
            }

            async function purgeRoom() {
                dom.purgeOverlay.classList.remove('hidden');
                
                // Clear timers
                if (state.ratchetTimer) clearInterval(state.ratchetTimer);
                if (state.countdownTimer) clearInterval(state.countdownTimer);
                if (state.dummyTrafficTimer) clearInterval(state.dummyTrafficTimer);
                
                // Close all connections
                state.connections.forEach(pc => pc.close());
                state.dataChannels.forEach(({ channel }) => channel.close());
                
                // Zeroize crypto keys
                if (state.cryptoContext) {
                    await CryptoModule.zeroizeContext(state.cryptoContext);
                }
                
                // Clear Firebase listeners
                if (state.unsubscribeSignals) state.unsubscribeSignals();
                if (state.unsubscribeRoom) state.unsubscribeRoom();
                
                // Notify Firebase
                await FirebaseAPI.leaveRoom(state.roomId, state.peerId);
                
                // Clear state
                state.connections.clear();
                state.dataChannels.clear();
                state.peerNames.clear();
                state.pendingCandidates.clear();
                state.isJoined = false;
                
                // Overwrite sensitive memory
                state.roomId = null;
                state.peerId = null;
                state.cryptoContext = null;
                
                setTimeout(() => {
                    dom.purgeOverlay.classList.add('hidden');
                    dom.joinModal.classList.remove('hidden');
                    dom.roomCodeDisplay.innerHTML = 'Room: <strong>--------</strong>';
                    dom.messagesContainer.textContent = '';
                    dom.peerList.querySelectorAll('.peer-item').forEach(el => el.remove());
                    dom.emptyPeers.style.display = 'flex';
                    setConnectionStatus('', 'Disconnected');
                }, 2000);
            }

            function handleBeforeUnload() {
                if (state.isJoined) {
                    // Use sendBeacon for cleanup on page close
                    FirebaseAPI.leaveRoom(state.roomId, state.peerId);
                }
            }

            function init() {
                initDOM();
                
                dom.createBtn.addEventListener('click', createRoom);
                dom.joinBtn.addEventListener('click', joinRoom);
                dom.leaveBtn.addEventListener('click', leaveRoom);
                dom.sendBtn.addEventListener('click', sendMessage);
                
                dom.roomCodeInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') joinRoom();
                });
                
                dom.messageInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
                
                dom.attachBtn.addEventListener('click', () => {
                    dom.fileInput.click();
                });
                
                dom.fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        sendFile(e.target.files[0]);
                        e.target.value = '';
                    }
                });
                
                window.addEventListener('beforeunload', handleBeforeUnload);
                
                // Visibility change handler for memory hygiene
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden' && state.isJoined) {
                        // Could implement additional security measures here
                    }
                });
            }

            return { init };
        })();

        document.addEventListener('DOMContentLoaded', BlackKeep.init);
    </script>
</body>
</html>
